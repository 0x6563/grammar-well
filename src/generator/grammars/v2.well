lexer {
	start: "main"

	[main]
		- import string, ws, comment, l_star
		- when /on\s+load(?![a-zA-Z\d_])/ tag "T_WORD" highlight "tag" goto js_body
		- when /on\s+new(?![a-zA-Z\d_])/ tag "T_WORD" highlight "tag" goto js_body
		- when /lexer(?![a-zA-Z\d_])/ tag "T_WORD" highlight "tag" set lexer
		- when /grammar(?![a-zA-Z\d_])/ tag "T_WORD" highlight "tag" set grammar
		- when /config(?![a-zA-Z\d_])/ tag "T_WORD" highlight "tag" set config
		- import kv

	[config] sections {

		[opener]
			- skip /\s+/
			- when "{" tag "CBRACKET_L"

		[body]
			- import comment, kv
			- when "}" tag "CBRACKET_R" set main

	}

	[grammar] sections {

		[opener]
			- skip /\s+/
			- when "{" tag "CBRACKET_L"

		[body]
			- import comment, section_word, js_template, ws, regex, l_qmark, l_plus, l_star, kv, l_colon, l_comma, l_pipe, l_parenl, l_parenr, l_abracketl, l_abracketr, l_arrow, l_dsign, l_dash
			- when "}" tag "CBRACKET_R" set main

	}

	[lexer] sections {

		[opener]
			- skip /\s+/
			- when "{" tag "CBRACKET_L"

		[body]
			- import ws, comment, section_word, regex, l_comma, l_arrow, l_dash, kv, l_colon, lexer_sections
			- when "}" tag "CBRACKET_R" set main

	}

	[lexer_sections] sections {

		[opener]
			- when "{" tag "CBRACKET_L"

		[body]
			- import ws, comment, section_word, regex, l_comma, l_arrow, l_dash, kv

		[closer]
			- when "}" tag "CBRACKET_R"

	}

	[js_body]
		- import ws
		- when "{" tag "T_JSBODY" set js_literal

	[js_literal]
		default: tag "T_JSBODY";
		unmatched: tag "T_JSBODY";
		- import jsignore
		- when "{" highlight "annotation" goto js_literal
		- when "}" highlight "annotation" pop
		- when "(" highlight "annotation" goto js_literal
		- when ")" highlight "annotation" pop

	[js_template]
		- when "=>" highlight "annotation" goto js_template_inner

	[js_template_inner]
		- import ws
		- when "${" highlight "annotation" set js_literal
		- when "(" highlight "annotation" set js_literal
		- when "{" highlight "annotation" set js_literal
		- when "[" highlight "annotation" set js_literal

	[kv]
		- import string, ws, word, l_colon, integer, l_scolon

	[jsignore]
		- when /"(?:[^"\\\r\n]|\\.)*"/ tag "T_JSBODY"
		- when /'(?:[^'\\\r\n]|\\.)*'/ tag "T_JSBODY"
		- when /`(?:[^`\\]|\\.)*`/ tag "T_JSBODY"
		- when /\/(?:[^\/\\\r\n]|\\.)+\/[gmiyu]*/ tag "T_JSBODY"
		- when /\/\/[^\n]*/ tag "T_JSBODY"
		- when /\/\*.*\*\// tag "T_JSBODY"

	[string]
		- when /"(?:[^"\\\r\n]|\\.)*"/ tag "T_STRING" highlight "string"

	[string2]
		- when /'(?:[^'\\\r\n]|\\.)*'/ tag "T_STRING" highlight "string"

	[string3]
		- when /`(?:[^`\\]|\\.)*`/ tag "T_STRING" highlight "string"

	[regex]
		- when /\/(?:[^\/\\\r\n]|\\.)+\// tag "T_REGEX" highlight "regexp"

	[integer]
		- when /\d+/ tag "T_INTEGER" highlight "number"

	[word]
		- when /[a-zA-Z_][a-zA-Z_\d]*/ tag "T_WORD"

	[section_word]
		- when /\[\s*[a-zA-Z_][a-zA-Z_\d]*\s*\]/ tag "T_SECTWORD" highlight "type.identifier"

	[ws]
		- when /\s+/ tag "T_WS"

	[l_colon]
		- when ":" tag "L_COLON" highlight "keyword"

	[l_scolon]
		- when ";" tag "L_SCOLON"

	[l_qmark]
		- when "?" tag "L_QMARK"

	[l_plus]
		- when "+" tag "L_PLUS"

	[l_star]
		- when "*" tag "L_STAR"

	[l_comma]
		- when "," tag "L_COMMA"

	[l_pipe]
		- when "|" tag "L_PIPE" highlight "keyword"

	[l_parenl]
		- when "(" tag "L_PARENL"

	[l_parenr]
		- when ")" tag "L_PARENR"

	[l_cbracketl]
		- when "{" tag "CBRACKET_L"

	[l_cbracketr]
		- when "}" tag "CBRACKET_R"

	[l_abracketl]
		- when "<" tag "ABRACKET_L"

	[l_abracketr]
		- when ">" tag "ABRACKET_R"

	[l_squarel]
		- when "[" tag "L_SQUAREL" highlight "variable"

	[l_squarer]
		- when "]" tag "L_SQUARER" highlight "variable"

	[l_arrow]
		- when "->" tag "L_ARROW" highlight "keyword"

	[l_dsign]
		- when "$" tag "L_DSIGN"

	[l_dash]
		- when "-" tag "L_DASH"

	[comment]
		- when /\/\/[^\n]*/ tag "T_COMMENT" highlight "comment"

	[commentmulti]
		- when /\/\*.*\*\// tag "T_COMMENT" highlight "comment"

}

grammar {

	[main]
		| _ section_list _ => ( $1 )

	[section_list]
		| section => ( [$0] )
		| section __ section_list => ( [$0].concat($2) )

	[section]
		| "config" _ <CBRACKET_L> _ kv_list:list _ <CBRACKET_R> => ( { config: Object.assign(...$list) } )
		| "import" _ <L_STAR> _ "from" __ T_WORD:import _ <L_SCOLON> => ( { import: $import } )
		| "import" _ <L_STAR> _ "from" __ T_STRING:import _ <L_SCOLON> => ( { import: $import, path: true } )
		| "import" _ <L_STAR> _ "as" _ T_WORD:alias _ "from" __ T_WORD:import _ <L_SCOLON> => ( { import: $import, alias: $alias} )
		| "import" _ <L_STAR> _ "as" _ T_WORD:alias _ "from" __ T_STRING:import _ <L_SCOLON> => ( { import: $import, path: true, alias: $alias} )
		| "lexer" _ <CBRACKET_L> _ lexer:lexer _ <CBRACKET_R> => ( { lexer: Object.assign(...$lexer) } )
		| "grammar" _ <CBRACKET_L> _ grammar:grammar _ <CBRACKET_R> => ( { grammar: $grammar } )
		| /on\s+new/ _ T_JS:js => ( { body: $js } )
		| /on\s+new/ _ T_STRING:js => ( { body: $js, path: true } )
		| /on\s+load/ _ T_JS:js => ( { head: $js } )
		| /on\s+load/ _ T_STRING:js => ( { head: $js, path: true } )

	[lexer]
		| kv_list _ state_list => ( $0.concat({ states: $2 }) )
		| state_list => ( [{ states: $0 }] )

	[state_list]
		| state => ( [$0] )
		| state _ state_list => ( [$0].concat($2) )

	[state]
		| T_SECTWORD _ state_definition => ( { name: $0, state: $2 } )

	[state_definition]
		| state_config_list _ token_list => ( Object.assign($0, { rules: $2 }) )
		| token_list => ( { rules: $0 } )
		| "sections" _ "{" _ state_list _ "}" => ( { sections: $4} )

	[state_config_list]
		| state_config => ( $0 )
		| state_config _ state_config_list => ( Object.assign($0, $2) )

	[state_config]
		| T_WORD _ ":" _ token_definition_list _ ";" => ( {[$0]: Object.assign(...$4) } )

	[token_list]
		| token => ( data )
		| token _ token_list => ( [$0].concat($2) )

	[token]
		| <L_DASH> _ "import" _ word_list => ( { import: $4 } )
		| <L_DASH> _ token_definition_list => ( Object.assign(...$2) )

	[token_definition_list]
		| token_definition => ( data )
		| token_definition _ token_definition_list => ( [$0].concat($2) )

	[token_definition]
		| "open" _ T_STRING => ( { open: $2 } )
		| "close" _ T_STRING => ( { close: $2 } )
		| "tag" _ string_list => ( { tag: $2 } )
		| "when" _ T_STRING => ( { when: $2 } )
		| "when" _ T_REGEX => ( { when: $2 } )
		| "before" _ T_STRING => ( { when: $2, before: true } )
		| "before" _ T_REGEX => ( { when: $2, before: true } )
		| "skip" _ T_STRING => ( { when: $2, skip: true } )
		| "skip" _ T_REGEX => ( { when: $2, skip: true } )
		| "pop" => ( { pop: 1 } )
		| "pop" _ T_INTEGER => ( { pop: parseInt($2) } )
		| "pop" _ "all" => ( { pop: "all" } )
		| "highlight" _ T_STRING => ( { highlight: $2 } )
		| "embed" _ T_STRING => ( { embed: $2 } )
		| "unembed" => ( { unembed: true } )
		| "inset" => ( { inset: 1 } )
		| "inset" _ T_INTEGER => ( { inset: parseInt($2) } )
		| "set" _ T_WORD => ( { set: $2 } )
		| "goto" _ T_WORD => ( { goto: $2 } )
		| "type" _ T_STRING => ( { type: $2 } )

	[grammar]
		| kv_list _ grammar_rule_list => ( { config: Object.assign(...$0), rules: $2 } )
		| grammar_rule_list => ( { rules: $0 } )

	[grammar_rule_list]
		| grammar_rule => ( [$0] )
		| grammar_rule _ grammar_rule_list => ( [$0].concat($2) )

	[grammar_rule]
		| grammar_rule_name _ expression_list => ( { name: $0, expressions: $2 } )
		| grammar_rule_name __ POSTPROCESSOR:template _ expression_list:expressions => ( { name: $0, expressions: $expressions, postprocess: $template } )

	[grammar_rule_name]
		| T_SECTWORD => ( $0 )

	[expression_list]
		| expression => ( [$0] )
		| <L_PIPE> _ expression => ( [$2] )
		| expression_list _ <L_PIPE> _ expression => ( $0.concat([$4]) )

	[expression]
		| expression_symbol_list => ( { symbols: $0 } )
		| expression_symbol_list _ POSTPROCESSOR:template => ( { symbols: $0, postprocess: $template } )

	[expression_symbol_list]
		| expression_symbol
		| expression_symbol_list __ expression_symbol => ( $0.concat([$2]) )

	[expression_symbol]
		| expression_symbol_match => ( $0 )
		| expression_symbol_match <L_COLON> T_WORD => ( { ...$0,  alias: $2 } )
		| expression_symbol_match expression_repeater => ( { expression: $0, repeat: $1 } )
		| expression_symbol_match expression_repeater <L_COLON> T_WORD => ( { expression: $0, repeat: $1, alias: $4 } )

	[expression_symbol_match]
		| T_WORD => ( { rule: $0 } )
		| T_STRING "i"? => ( { literal: $0, insensitive: !!$1 } )
		| <ABRACKET_L> _ T_WORD:token _ <ABRACKET_R> => ( { token: $token} )
		| <ABRACKET_L> _ T_STRING:token _ <ABRACKET_R> => ( { token: $token} )
		| T_REGEX => ( $0 )
		| <L_PARENL> _ expression_list _ <L_PARENR> => ( { subexpression: $2 } )

	[expression_repeater] => ( $0.value )
		| <L_QMARK>
		| <L_PLUS>
		| <L_STAR>

	[kv_list]
		| kv => ( data )
		| kv _ kv_list => ( [$0].concat($2) )

	[kv]
		| T_WORD _ ":" _ (T_WORD | T_STRING | T_INTEGER | T_JS) => ( { [$0]: $4[0] } )

	[string_list]
		| T_STRING => ( [$0] )
		| T_STRING _ <L_COMMA> _ string_list => ( [$0].concat($4) )

	[word_list]
		| T_WORD => ( [$0] )
		| T_WORD _ <L_COMMA> _ word_list => ( [$0].concat($4) )

	[_]
		| (<T_WS> | <T_COMMENT>)* => ( null )

	[__]
		| (<T_WS> | <T_COMMENT>)+ => ( null )

	[T_JS]
		| "{" <T_JSBODY>* "}" => ( { js: $1.map(v=>v.value).join('') } )

	[POSTPROCESSOR] => ( { template: $2.value + $3.map(v=>v.value).join('').trim() + $4.value} )
		| "=>" _ "(" <T_JSBODY>* ")"
		| "=>" _ "{" <T_JSBODY>* "}"
		| "=>" _ "[" <T_JSBODY>* "]"
		| "=>" _ "${" <T_JSBODY>* "}" => ( { js: $3.map(v=>v.value).join('').trim() } )

	[T_STRING]
		| <T_STRING> => ( JSON.parse($0.value) )

	[T_WORD]
		| <T_WORD> => ( $0.value )

	[T_SECTWORD]
		| <T_SECTWORD> => ( $0.value.substring(1, $0.value.length-1).trim() )

	[T_REGEX]
		| <T_REGEX> /[gmiuy]/* => ( { regex: $0.value.slice(1,-1), flags: $1.map(v=>v.value).join('').trim() } )

	[T_INTEGER]
		| <T_INTEGER> => ( $0.value )

}
