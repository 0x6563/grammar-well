lexer {
	start: "start"

	[start]
		- import string, ws, comment, l_star
		- when /head(?![a-zA-Z\d_])/ tag "T_WORD" highlight "tag" goto js_body
		- when /body(?![a-zA-Z\d_])/ tag "T_WORD" highlight "tag" goto js_body
		- when /lexer(?![a-zA-Z\d_])/ tag "T_WORD" highlight "tag" goto lexer
		- import grammar
		- when /config(?![a-zA-Z\d_])/ tag "T_WORD" highlight "tag" goto config
		- import kv

	[config]
		- import ws
		- when "{" tag "CBRACKET_L" set config_inner

	[config_inner]
		- import comment, kv
		- when "}" tag "CBRACKET_R" pop

	[grammar] sections {

		[opener]
			- before /grammar(?![a-zA-Z\d_])\s*{/

		[body]
			- when "{" tag "CBRACKET_L"
			- import comment, section_word, js_template, ws, regex, l_qmark, l_plus, l_star, kv, l_colon, l_comma, l_pipe, l_parenl, l_parenr, l_arrow, l_dsign, l_dash

		[closer]
			- when "}" tag "CBRACKET_R"

	}

	[lexer]
		- import ws
		- when "{" tag "CBRACKET_L" highlight "bracket" set lexer_inner

	[lexer_inner]
		- import ws, comment, section_word, regex, l_comma, l_arrow, l_dash, kv, l_colon
		- when "{" tag "CBRACKET_L" goto lexer_sections
		- when "}" tag "CBRACKET_R" pop

	[lexer_sections]
		- import ws, comment, section_word, regex, l_comma, l_arrow, l_dash, kv
		- when "}" tag "CBRACKET_R" pop

	[js_body]
		- import ws
		- when "{" tag "T_JSBODY" set js_literal

	[js_literal]
		default: tag "T_JSBODY";
		unmatched: tag "T_JSBODY";
		- import jsignore
		- when "{" highlight "annotation" goto js_literal
		- when "}" highlight "annotation" pop
		- when "(" highlight "annotation" goto js_literal
		- when ")" highlight "annotation" pop

	[js_template]
		- when "=>" highlight "annotation" goto js_template_inner

	[js_template_inner]
		- import ws
		- when "${" highlight "annotation" set js_literal
		- when "(" highlight "annotation" set js_literal
		- when "{" highlight "annotation" set js_literal
		- when "[" highlight "annotation" set js_literal

	[kv]
		- import string, ws, word, l_colon, integer, l_scolon

	[jsignore]
		- when /"(?:[^"\\\r\n]|\\.)*"/ tag "T_JSBODY"
		- when /'(?:[^'\\\r\n]|\\.)*'/ tag "T_JSBODY"
		- when /`(?:[^`\\]|\\.)*`/ tag "T_JSBODY"
		- when /\/(?:[^\/\\\r\n]|\\.)+\/[gmiyu]*/ tag "T_JSBODY"
		- when /\/\/[^\n]*/ tag "T_JSBODY"
		- when /\/\*.*\*\// tag "T_JSBODY"

	[string]
		- when /"(?:[^"\\\r\n]|\\.)*"/ tag "T_STRING" highlight "string"

	[string2]
		- when /'(?:[^'\\\r\n]|\\.)*'/ tag "T_STRING" highlight "string"

	[string3]
		- when /`(?:[^`\\]|\\.)*`/ tag "T_STRING" highlight "string"

	[regex]
		- when /\/(?:[^\/\\\r\n]|\\.)+\// tag "T_REGEX" highlight "regexp"

	[integer]
		- when /\d+/ tag "T_INTEGER" highlight "number"

	[word]
		- when /[a-zA-Z_][a-zA-Z_\d]*/ tag "T_WORD"

	[section_word]
		- when /\[\s*[a-zA-Z_][a-zA-Z_\d]*\s*\]/ tag "T_SECTWORD" highlight "type.identifier"

	[ws]
		- when /\s+/ tag "T_WS"

	[l_colon]
		- when ":" tag "L_COLON" highlight "keyword"

	[l_scolon]
		- when ";" tag "L_SCOLON"

	[l_qmark]
		- when "?" tag "L_QMARK"

	[l_plus]
		- when "+" tag "L_PLUS"

	[l_star]
		- when "*" tag "L_STAR"

	[l_comma]
		- when "," tag "L_COMMA"

	[l_pipe]
		- when "|" tag "L_PIPE" highlight "keyword"

	[l_parenl]
		- when "(" tag "L_PARENL"

	[l_parenr]
		- when ")" tag "L_PARENR"

	[l_cbracketl]
		- when "{" tag "CBRACKET_L"

	[l_cbracketr]
		- when "}" tag "CBRACKET_R"

	[l_squarel]
		- when "[" tag "L_SQUAREL" highlight "variable"

	[l_squarer]
		- when "]" tag "L_SQUARER" highlight "variable"

	[l_arrow]
		- when "->" tag "L_ARROW" highlight "keyword"

	[l_dsign]
		- when "$" tag "L_DSIGN"

	[l_dash]
		- when "-" tag "L_DASH"

	[comment]
		- when /\/\/[^\n]*/ tag "T_COMMENT" highlight "comment"

	[commentmulti]
		- when /\/\*.*\*\// tag "T_COMMENT" highlight "comment"

}

grammar {

	[main]
		| _ section_list _ => ( $1 )

	[section_list]
		| section => ( [$0] )
		| section T_WS section_list => ( [$0].concat($2) )

	[section]
		| K_CONFIG _ CBRACKET_L _ kv_list:list _ CBRACKET_R => ( { config: Object.assign(...$list) } )
		| K_IMPORT _ L_STAR _ K_FROM __ T_WORD:import _ L_SCOLON => ( { import: $import } )
		| K_IMPORT _ L_STAR _ K_FROM __ T_STRING:import _ L_SCOLON => ( { import: $import, path: true } )
		| K_IMPORT _ L_STAR _ "as" _ T_WORD:alias _ K_FROM __ T_WORD:import _ L_SCOLON => ( { import: $import, alias: $alias} )
		| K_IMPORT _ L_STAR _ "as" _ T_WORD:alias _ K_FROM __ T_STRING:import _ L_SCOLON => ( { import: $import, path: true, alias: $alias} )
		| K_LEXER _ CBRACKET_L _ lexer:lexer _ CBRACKET_R => ( { lexer: Object.assign(...$lexer) } )
		| K_GRAMMAR _ CBRACKET_L _ grammar:grammar _ CBRACKET_R => ( { grammar: $grammar } )
		| K_BODY _ T_JS:js => ( { body: $js } )
		| K_BODY _ T_STRING:js => ( { body: $js, path: true } )
		| K_HEAD _ T_JS:js => ( { head: $js } )
		| K_HEAD _ T_STRING:js => ( { head: $js, path: true } )

	[lexer]
		| kv_list _ state_list => ( $0.concat({ states: $2 }) )
		| state_list => ( [{ states: $0 }] )

	[state_list]
		| state => ( [$0] )
		| state _ state_list => ( [$0].concat($2) )

	[state]
		| T_SECTWORD _ state_definition => ( { name: $0, state: $2 } )

	[state_definition]
		| state_config_list _ token_list => ( Object.assign($0, { rules: $2 }) )
		| token_list => ( { rules: $0 } )
		| "sections" _ "{" _ state_list _ "}" => ( { sections: $4} )

	[state_config_list]
		| state_config => ( $0 )
		| state_config _ state_config_list => ( Object.assign($0, $2) )

	[state_config]
		| T_WORD _ ":" _ token_definition_list _ ";" => ( {[$0]: Object.assign(...$4) } )

	[token_list]
		| token => ( data )
		| token _ token_list => ( [$0].concat($2) )

	[token]
		| L_DASH _ K_IMPORT _ word_list => ( { import: $4 } )
		| L_DASH _ token_definition_list => ( Object.assign(...$2) )

	[token_definition_list]
		| token_definition => ( data )
		| token_definition _ token_definition_list => ( [$0].concat($2) )

	[token_definition]
		| K_TAG _ string_list => ( { tag: $2 } )
		| K_WHEN _ T_STRING => ( { when: $2 } )
		| K_WHEN _ T_REGEX => ( { when: $2 } )
		| K_OPEN _ T_STRING => ( { open: $2 } )
		| K_CLOSE _ T_STRING => ( { close: $2 } )
		| K_BEFORE _ T_STRING => ( { when: $2, before: true } )
		| K_BEFORE _ T_REGEX => ( { when: $2, before: true } )
		| K_POP => ( { pop: 1 } )
		| K_POP _ T_INTEGER => ( { pop: parseInt($2) } )
		| K_POP _ K_ALL => ( { pop: "all" } )
		| K_HIGHLIGHT _ T_STRING => ( { highlight: $2 } )
		| K_EMBED _ T_STRING => ( { embed: $2 } )
		| K_UNEMBED => ( { unembed: true } )
		| K_INSET => ( { inset: 1 } )
		| K_INSET _ T_INTEGER => ( { inset: parseInt($2) } )
		| K_SET _ T_WORD => ( { set: $2 } )
		| K_GOTO _ T_WORD => ( { goto: $2 } )
		| K_TYPE _ T_STRING => ( { type: $2 } )

	[grammar]
		| kv_list _ grammar_rule_list => ( { config: Object.assign(...$0), rules: $2 } )
		| grammar_rule_list => ( { rules: $0 } )

	[grammar_rule_list]
		| grammar_rule => ( [$0] )
		| grammar_rule _ grammar_rule_list => ( [$0].concat($2) )

	[grammar_rule]
		| grammar_rule_name _ expression_list => ( { name: $0, expressions: $2 } )
		| grammar_rule_name __ POSTPROCESSOR:template _ expression_list:expressions => ( { name: $0, expressions: $expressions, postprocess: $template } )

	[grammar_rule_name]
		| T_SECTWORD => ( $0 )

	[expression_list]
		| expression => ( [$0] )
		| L_PIPE _ expression => ( [$2] )
		| expression_list _ L_PIPE _ expression => ( $0.concat([$4]) )

	[expression]
		| expression_symbol_list => ( { symbols: $0 } )
		| expression_symbol_list _ POSTPROCESSOR:template => ( { symbols: $0, postprocess: $template } )

	[expression_symbol_list]
		| expression_symbol
		| expression_symbol_list T_WS expression_symbol => ( $0.concat([$2]) )

	[expression_symbol]
		| expression_symbol_match => ( $0 )
		| expression_symbol_match L_COLON T_WORD => ( { ...$0,  alias: $2 } )
		| expression_symbol_match expression_repeater => ( { expression: $0, repeat: $1 } )
		| expression_symbol_match expression_repeater L_COLON T_WORD => ( { expression: $0, repeat: $1, alias: $4 } )

	[expression_symbol_match]
		| T_WORD => ( { rule: $0 } )
		| T_STRING "i"? => ( { literal: $0, insensitive: !!$1 } )
		| L_DSIGN T_WORD => ( { token: $1} )
		| L_DSIGN T_STRING => ( { token: $1} )
		| T_REGEX => ( $0 )
		| L_PARENL _ expression_list _ L_PARENR => ( { subexpression: $2 } )

	[expression_repeater] => ( $0[0].value )
		| L_QMARK
		| L_PLUS
		| L_STAR

	[kv_list]
		| kv => ( data )
		| kv _ kv_list => ( [$0].concat($2) )

	[kv]
		| T_WORD _ ":" _ (T_WORD | T_STRING | T_INTEGER | T_JS) => ( { [$0]: $4[0] } )

	[string_list]
		| T_STRING => ( [$0] )
		| T_STRING _ L_COMMA _ string_list => ( [$0].concat($4) )

	[word_list]
		| T_WORD => ( [$0] )
		| T_WORD _ L_COMMA _ word_list => ( [$0].concat($4) )

	[_]
		| (T_WS | T_COMMENT)* => ( null )

	[__]
		| (T_WS | T_COMMENT)+ => ( null )

	[L_COLON]
		| $L_COLON

	[L_SCOLON]
		| $L_SCOLON

	[L_QMARK]
		| $L_QMARK

	[L_PLUS]
		| $L_PLUS

	[L_STAR]
		| $L_STAR

	[L_COMMA]
		| $L_COMMA

	[L_PIPE]
		| $L_PIPE

	[L_PARENL]
		| $L_PARENL

	[L_PARENR]
		| $L_PARENR

	[CBRACKET_L]
		| $CBRACKET_L

	[CBRACKET_R]
		| $CBRACKET_R

	[DCBRACKET_L]
		| $DCBRACKET_L

	[DCBRACKET_R]
		| $DCBRACKET_R

	[L_ARROW]
		| $L_ARROW

	[L_DSIGN]
		| $L_DSIGN

	[L_DASH]
		| $L_DASH

	[K_ALL]
		| "all"

	[K_TAG]
		| "tag"

	[K_FROM]
		| "from"

	[K_TYPE]
		| "type"

	[K_WHEN]
		| "when"

	[K_POP]
		| "pop"

	[K_BEFORE]
		| "before"

	[K_OPEN]
		| "open"

	[K_CLOSE]
		| "close"

	[K_HIGHLIGHT]
		| "highlight"

	[K_EMBED]
		| "embed"

	[K_UNEMBED]
		| "unembed"

	[K_INSET]
		| "inset"

	[K_SET]
		| "set"

	[K_GOTO]
		| "goto"

	[K_CONFIG]
		| "config"

	[K_LEXER]
		| "lexer"

	[K_GRAMMAR]
		| "grammar"

	[K_IMPORT]
		| "import"

	[K_BODY]
		| "body"

	[K_HEAD]
		| "head"

	[T_JS]
		| "{" $T_JSBODY* "}" => ( { js: $1.map(v=>v.value).join('') } )

	[POSTPROCESSOR] => ( { template: $2.value + $3.map(v=>v.value).join('').trim() + $4.value} )
		| "=>" _ "(" $T_JSBODY* ")"
		| "=>" _ "{" $T_JSBODY* "}"
		| "=>" _ "[" $T_JSBODY* "]"
		| "=>" _ "${" $T_JSBODY* "}" => ( { js: $3.map(v=>v.value).join('').trim() } )

	[T_STRING]
		| $T_STRING => ( JSON.parse($0.value) )

	[T_WORD]
		| $T_WORD => ( $0.value )

	[T_SECTWORD]
		| $T_SECTWORD => ( $0.value.substring(1, $0.value.length-1).trim() )

	[T_REGEX]
		| $T_REGEX /[gmiuy]/* => ( { regex: $0.value.slice(1,-1), flags: $1.map(v=>v.value).join('').trim() } )

	[T_COMMENT]
		| $T_COMMENT

	[T_INTEGER]
		| $T_INTEGER => ( $0.value )

	[T_WS]
		| $T_WS => ( null )

}
