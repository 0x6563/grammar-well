{"grammar":{"rules":[{"name":"final$ebnf$1","symbols":[{"token":"(lexer.has(\"ws\") ? {type: \"ws\"} : ws)"}],"postprocess":{"builtin":"id"}},{"name":"final$ebnf$1","symbols":[],"postprocess":{"builtin":"nuller"}},{"name":"final","symbols":["_","prog","_","final$ebnf$1"]},{"name":"prog","symbols":["prod"]},{"name":"prog","symbols":["prod","ws","prog"]},{"name":"prod","symbols":["word","_",{"token":"(lexer.has(\"arrow\") ? {type: \"arrow\"} : arrow)"},"_","expression+"]},{"name":"prod","symbols":["word",{"literal":"["},"_","wordlist","_",{"literal":"]"},"_",{"token":"(lexer.has(\"arrow\") ? {type: \"arrow\"} : arrow)"},"_","expression+"]},{"name":"prod","symbols":[{"literal":"@"},"_","js"]},{"name":"prod","symbols":[{"literal":"@"},"word","ws","word"]},{"name":"prod","symbols":[{"literal":"@include"},"_","string"]},{"name":"prod","symbols":[{"literal":"@builtin"},"_","string"]},{"name":"expression+","symbols":["completeexpression"]},{"name":"expression+","symbols":["expression+","_",{"literal":"|"},"_","completeexpression"]},{"name":"expressionlist","symbols":["completeexpression"]},{"name":"expressionlist","symbols":["expressionlist","_",{"literal":","},"_","completeexpression"]},{"name":"wordlist","symbols":["word"]},{"name":"wordlist","symbols":["wordlist","_",{"literal":","},"_","word"]},{"name":"completeexpression","symbols":["expr"]},{"name":"completeexpression","symbols":["expr","_","js"]},{"name":"expr_member","symbols":["word"]},{"name":"expr_member","symbols":[{"literal":"$"},"word"]},{"name":"expr_member","symbols":["word",{"literal":"["},"_","expressionlist","_",{"literal":"]"}]},{"name":"expr_member$ebnf$1","symbols":[{"literal":"i"}],"postprocess":{"builtin":"id"}},{"name":"expr_member$ebnf$1","symbols":[],"postprocess":{"builtin":"nuller"}},{"name":"expr_member","symbols":["string","expr_member$ebnf$1"]},{"name":"expr_member","symbols":[{"literal":"%"},"word"]},{"name":"expr_member","symbols":["charclass"]},{"name":"expr_member","symbols":[{"literal":"("},"_","expression+","_",{"literal":")"}]},{"name":"expr_member","symbols":["expr_member","_","ebnf_modifier"]},{"name":"ebnf_modifier","symbols":[{"literal":":+"}]},{"name":"ebnf_modifier","symbols":[{"literal":":*"}]},{"name":"ebnf_modifier","symbols":[{"literal":":?"}]},{"name":"expr","symbols":["expr_member"]},{"name":"expr","symbols":["expr","ws","expr_member"]},{"name":"word","symbols":[{"token":"(lexer.has(\"word\") ? {type: \"word\"} : word)"}]},{"name":"string","symbols":[{"token":"(lexer.has(\"string\") ? {type: \"string\"} : string)"}]},{"name":"string","symbols":[{"token":"(lexer.has(\"btstring\") ? {type: \"btstring\"} : btstring)"}]},{"name":"charclass","symbols":[{"token":"(lexer.has(\"charclass\") ? {type: \"charclass\"} : charclass)"}]},{"name":"js","symbols":[{"token":"(lexer.has(\"js\") ? {type: \"js\"} : js)"}]},{"name":"_$ebnf$1","symbols":["ws"],"postprocess":{"builtin":"id"}},{"name":"_$ebnf$1","symbols":[],"postprocess":{"builtin":"nuller"}},{"name":"_","symbols":["_$ebnf$1"]},{"name":"ws","symbols":[{"token":"(lexer.has(\"ws\") ? {type: \"ws\"} : ws)"}]},{"name":"ws$ebnf$1","symbols":[{"token":"(lexer.has(\"ws\") ? {type: \"ws\"} : ws)"}],"postprocess":{"builtin":"id"}},{"name":"ws$ebnf$1","symbols":[],"postprocess":{"builtin":"nuller"}},{"name":"ws","symbols":["ws$ebnf$1",{"token":"(lexer.has(\"comment\") ? {type: \"comment\"} : comment)"},"_"]}],"head":[],"body":["\nfunction getValue(d) {\n    return d[0].value\n}\n\nfunction literals(list) {\n    var rules = {}\n    for (var lit of list) {\n        rules[lit] = {match: lit, next: 'main'}\n    }\n    return rules\n}\n\nvar moo = require('moo')\nvar rules = Object.assign({\n    ws: {match: /\\s+/, lineBreaks: true, next: 'main'},\n    comment: /\\#.*/,\n    arrow: {match: /[=-]+\\>/, next: 'main'},\n    js: {\n        match: /\\{\\%(?:[^%]|\\%[^}])*\\%\\}/,\n        value: x => x.slice(2, -2),\n        lineBreaks: true,\n    },\n    word: {match: /[\\w\\?\\+]+/, next: 'afterWord'},\n    string: {\n        match: /\"(?:[^\\\\\"\\n]|\\\\[\"\\\\/bfnrt]|\\\\u[a-fA-F0-9]{4})*\"/,\n        value: x => JSON.parse(x),\n        next: 'main',\n    },\n    btstring: {\n        match: /`[^`]*`/,\n        value: x => x.slice(1, -1),\n        next: 'main',\n        lineBreaks: true,\n    },\n}, literals([\n    \",\", \"|\", \"$\", \"%\", \"(\", \")\",\n    \":?\", \":*\", \":+\",\n    \"@include\", \"@builtin\", \"@\",\n    \"]\",\n]))\n\nvar lexer = moo.states({\n    main: Object.assign({}, rules, {\n        charclass: {\n            match: /\\.|\\[(?:\\\\.|[^\\\\\\n])+?\\]/,\n            value: x => new RegExp(x),\n        },\n    }),\n    // Both macro arguments and charclasses are both enclosed in [ ].\n    // We disambiguate based on whether the previous token was a `word`.\n    afterWord: Object.assign({}, rules, {\n        \"[\": {match: \"[\", next: 'main'},\n    }),\n})\n\nfunction insensitive(sl) {\n    var s = sl.literal;\n    var result = [];\n    for (var i=0; i<s.length; i++) {\n        var c = s.charAt(i);\n        if (c.toUpperCase() !== c || c.toLowerCase() !== c) {\n            result.push(new RegExp(\"[\" + c.toLowerCase() + c.toUpperCase() + \"]\"));\n            } else {\n            result.push({literal: c});\n        }\n    }\n    return {subexpression: [{tokens: result, postprocess: function(d) {return d.join(\"\"); }}]};\n}\n\n"],"customTokens":["ws","arrow","word","string","btstring","charclass","js","comment"],"config":{"lexer":"lexer"},"macros":{},"start":"final","version":"unknown"},"exportName":"grammar"}