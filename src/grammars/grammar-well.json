{"grammar":{"rules":[{"name":"final$ebnf$1","symbols":[{"token":"(lexer.has(\"ws\") ? {type: \"ws\"} : ws)"}],"postprocess":{"builtin":"id"}},{"name":"final$ebnf$1","symbols":[],"postprocess":{"builtin":"nuller"}},{"name":"final","symbols":["_","prog","_","final$ebnf$1"],"postprocess":" function({data}) { return data[1]; } "},{"name":"prog","symbols":["prod"],"postprocess":" function({data}) { return [data[0]]; } "},{"name":"prog","symbols":["prod","ws","prog"],"postprocess":" function({data}) { return [data[0]].concat(data[2]); } "},{"name":"prod","symbols":["word","_",{"token":"(lexer.has(\"arrow\") ? {type: \"arrow\"} : arrow)"},"_","expression+"],"postprocess":" function({data}) { return {name: data[0], rules: data[4]}; } "},{"name":"prod","symbols":["word",{"literal":"["},"_","wordlist","_",{"literal":"]"},"_",{"token":"(lexer.has(\"arrow\") ? {type: \"arrow\"} : arrow)"},"_","expression+"],"postprocess":" function({data}) {return {macro: data[0], args: data[3], exprs: data[9]}} "},{"name":"prod","symbols":[{"literal":"@"},"_","js"],"postprocess":" function({data}) { return {body: data[2]}; } "},{"name":"prod","symbols":[{"literal":"@body"},"_","js"],"postprocess":" function({data}) { return {body: data[2]}; } "},{"name":"prod","symbols":[{"literal":"@head"},"_","js"],"postprocess":" function({data}) { return {head: data[2]}; } "},{"name":"prod","symbols":[{"literal":"@include"},"_","string"],"postprocess":" function({data}) {return {include: data[2].literal, builtin: false}} "},{"name":"prod","symbols":[{"literal":"@builtin"},"_","string"],"postprocess":" function({data}) {return {include: data[2].literal, builtin: true }} "},{"name":"prod","symbols":[{"literal":"@"},"word","ws","word"],"postprocess":" function({data}) { return {config: data[1], value: data[3]}; } "},{"name":"expression+","symbols":["completeexpression"]},{"name":"expression+","symbols":["expression+","_",{"literal":"|"},"_","completeexpression"],"postprocess":" function({data}) { return data[0].concat([data[4]]); } "},{"name":"expressionlist","symbols":["completeexpression"]},{"name":"expressionlist","symbols":["expressionlist","_",{"literal":","},"_","completeexpression"],"postprocess":" function({data}) { return data[0].concat([data[4]]); } "},{"name":"wordlist","symbols":["word"]},{"name":"wordlist","symbols":["wordlist","_",{"literal":","},"_","word"],"postprocess":" function({data}) { return data[0].concat([data[4]]); } "},{"name":"completeexpression","symbols":["expr"],"postprocess":" function({data}) { return {tokens: data[0]}; } "},{"name":"completeexpression","symbols":["expr","_","js"],"postprocess":" function({data}) { return {tokens: data[0], postprocess: data[2]}; } "},{"name":"expr_member","symbols":["word"],"postprocess":" ({data}) => data[0] "},{"name":"expr_member","symbols":[{"literal":"$"},"word"],"postprocess":" function({data}) {return {mixin: data[1]}} "},{"name":"expr_member","symbols":["word",{"literal":"["},"_","expressionlist","_",{"literal":"]"}],"postprocess":" function({data}) {return {macrocall: data[0], args: data[3]}} "},{"name":"expr_member$ebnf$1","symbols":[{"literal":"i"}],"postprocess":{"builtin":"id"}},{"name":"expr_member$ebnf$1","symbols":[],"postprocess":{"builtin":"nuller"}},{"name":"expr_member","symbols":["string","expr_member$ebnf$1"],"postprocess":" function({data}) { return data[1] ? insensitive(data[0]) : data[0]; } "},{"name":"expr_member","symbols":[{"literal":"%"},"word"],"postprocess":" function({data}) {return {token: data[1]}} "},{"name":"expr_member","symbols":["charclass"],"postprocess":" ({data}) => data[0] "},{"name":"expr_member","symbols":[{"literal":"("},"_","expression+","_",{"literal":")"}],"postprocess":" function({data}) {return {'subexpression': data[2]} ;} "},{"name":"expr_member","symbols":["expr_member","_","ebnf_modifier"],"postprocess":" function({data}) {return {'ebnf': data[0], 'modifier': data[2]}; } "},{"name":"ebnf_modifier","symbols":[{"literal":":+"}],"postprocess":" getValue "},{"name":"ebnf_modifier","symbols":[{"literal":":*"}],"postprocess":" getValue "},{"name":"ebnf_modifier","symbols":[{"literal":":?"}],"postprocess":" getValue "},{"name":"expr","symbols":["expr_member"]},{"name":"expr","symbols":["expr","ws","expr_member"],"postprocess":" function({data}){ return data[0].concat([data[2]]); } "},{"name":"word","symbols":[{"token":"(lexer.has(\"word\") ? {type: \"word\"} : word)"}],"postprocess":" getValue "},{"name":"string","symbols":[{"token":"(lexer.has(\"string\") ? {type: \"string\"} : string)"}],"postprocess":" ({data}) => ({literal: data[0].value}) "},{"name":"string","symbols":[{"token":"(lexer.has(\"btstring\") ? {type: \"btstring\"} : btstring)"}],"postprocess":" ({data}) => ({literal: data[0].value}) "},{"name":"charclass","symbols":[{"token":"(lexer.has(\"charclass\") ? {type: \"charclass\"} : charclass)"}],"postprocess":" getValue "},{"name":"js","symbols":[{"token":"(lexer.has(\"js\") ? {type: \"js\"} : js)"}],"postprocess":" getValue "},{"name":"_$ebnf$1","symbols":["ws"],"postprocess":{"builtin":"id"}},{"name":"_$ebnf$1","symbols":[],"postprocess":{"builtin":"nuller"}},{"name":"_","symbols":["_$ebnf$1"]},{"name":"ws","symbols":[{"token":"(lexer.has(\"ws\") ? {type: \"ws\"} : ws)"}]},{"name":"ws$ebnf$1","symbols":[{"token":"(lexer.has(\"ws\") ? {type: \"ws\"} : ws)"}],"postprocess":{"builtin":"id"}},{"name":"ws$ebnf$1","symbols":[],"postprocess":{"builtin":"nuller"}},{"name":"ws","symbols":["ws$ebnf$1",{"token":"(lexer.has(\"comment\") ? {type: \"comment\"} : comment)"},"_"]}],"head":["\n// Head\n"],"body":["\n// Body\nfunction getValue({ data }) {\n    return data[0].value;\n}\n\nfunction literals(list) {\n    const rules = {}\n    for (let lit of list) {\n        rules[lit] = { match: lit, next: 'main' }\n    }\n    return rules;\n}\n\nconst moo = require('moo');\nconst rules = Object.assign({\n    ws: { match: /\\s+/, lineBreaks: true, next: 'main' },\n    comment: /\\#.*/,\n    arrow: { match: /[=-]+\\>/, next: 'main' },\n    js: {\n        match: /\\{\\%(?:[^%]|\\%[^}])*\\%\\}/,\n        value: x => x.slice(2, -2),\n        lineBreaks: true,\n    }, \n    word: { match: /[\\w\\?\\+]+/, next: 'afterWord' },\n    string: {\n        match: /\"(?:[^\\\\\"\\n]|\\\\[\"\\\\/bfnrt]|\\\\u[a-fA-F0-9]{4})*\"/,\n        value: x => JSON.parse(x),\n        next: 'main',\n    },\n    btstring: {\n        match: /`[^`]*`/,\n        value: x => x.slice(1, -1),\n        next: 'main',\n        lineBreaks: true,\n    },\n}, literals([\n    \",\", \"|\", \"$\", \"%\", \"(\", \")\",\n    \":?\", \":*\", \":+\",\n    \"@include\", \"@builtin\", \"@head\", \"@body\", \"@\",\n    \"]\",\n]));\n\nconst lexer = moo.states({\n    main: Object.assign({}, rules, {\n        charclass: {\n            match: /\\.|\\[(?:\\\\.|[^\\\\\\n])+?\\]/,\n            value: x => new RegExp(x),\n        },\n    }),\n    // Both macro arguments and charclasses are both enclosed in [ ].\n    // We disambiguate based on whether the previous token was a `word`.\n    afterWord: Object.assign({}, rules, literals(['['])),\n});\n\nfunction insensitive({ literal }) {\n    const tokens = [];\n    for (let i = 0; i < literal.length; i++) {\n        const c = literal.charAt(i);\n        if (c.toUpperCase() !== c || c.toLowerCase() !== c) {\n            tokens.push(new RegExp(\"[\" + c.toLowerCase() + c.toUpperCase() + \"]\"));\n        } else {\n            tokens.push({ literal: c });\n        }\n    }\n    return { subexpression: [{ tokens, postprocess: ({data}) => data.join('') }] };\n}\n\n"],"customTokens":["ws","arrow","word","string","btstring","charclass","js","comment"],"config":{"lexer":"lexer"},"macros":{},"start":"final","version":"unknown"},"exportName":"grammar"}