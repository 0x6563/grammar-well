head ${
 
    function Insensitive({ literal }) {
        const tokens = [];
        for (let i = 0; i < literal.length; i++) {
            const c = literal.charAt(i);
            if (c.toUpperCase() !== c || c.toLowerCase() !== c) {
                tokens.push(new RegExp("[" + c.toLowerCase() + c.toUpperCase() + "]"));
            } else {
                tokens.push({ literal: c });
            }
        }
        return { subexpression: [{ tokens, postprocess: ({data}) => data.join('') }] };
    }
    
	function Rollup(ary){
		const r = {};
		for(const i of ary){
			for(const k in i){
				r[k] = i[k];
			}
		}

		return r;
	};

	function TemplatePostProcess(str){
		return "function({data}) { return " + str.replace(/\$(\d+)/g, "data[$1]") + "}"
	}
}

lexer {{
    start ->
        - import: string, js_pre, ws, comment
        - when: /lexer(?![a-zA-Z\d_])/ type: "K_LEXER" goto: lexer_pre
        - when: /grammar(?![a-zA-Z\d_])/ type: "K_GRAMMAR" goto: grammar_pre
        - when: /config(?![a-zA-Z\d_])/ type: "K_CONFIG" goto: config_pre
        - import: k_config, k_import, k_head, k_body, kv
    config_pre ->
        - import: ws
        - when: "{{" type: "L_TEMPLATEL"
    config ->
        - import: comment, kv
        - when: "}}" type: "L_TEMPLATER" pop: 1
    grammar_pre ->
        - import: ws
        - when: "{{" type: "L_TEMPLATEL"
    grammar ->
        - import: comment, js_pre, js_templatepre, ws, regex, charclass, l_ebnf_0, l_ebnf_1n, l_ebnf_0n, kv, l_colon, l_comma, l_pipe, l_parenl, l_parenr, l_arrow, l_dsign, l_dash
        - when: "}}" type: "L_TEMPLATER" pop: 1
    lexer_pre ->
        - import: ws
        - when: "{{" type: "L_TEMPLATEL"
    lexer ->
        - import: ws, kv, regex, l_comma, l_arrow, l_dash, comment, js_pre
        - when: "}}" type: "L_TEMPLATER" pop: 1
    js_pre ->
        - when: "${" type: "L_JSL" goto: js_wrap
    js_wrap ->
        default: "T_JSBODY"
        unmatched: "T_JSBODY"
        - import: jsignore
        - when: "{" type: "T_JSBODY" goto: js
        - when: "}" type: "L_JSR" pop: 1
    js ->
        default: "T_JSBODY"
        unmatched: "T_JSBODY"
        - import: jsignore
        - when: "{" type: "T_JSBODY" goto: js
        - when: "}" type: "T_JSBODY" pop: 1
    js_templatepre ->
        - when: "{{" type: "L_TEMPLATEL" goto: js_templatewrap
    js_templatewrap ->
        default: "T_JSBODY"
        unmatched: "T_JSBODY"
        - import: jsignore
        - when: "{" type: "T_JSBODY" goto: js
        - when: "}}" type: "L_TEMPLATER" pop: 1
    kv ->
        - import: string, ws, word, l_colon, integer
    jsignore ->
        - when: /"(?:[^"\\]|\\.)*"/ type: "T_JSBODY"
        - when: /'(?:[^'\\]|\\.)*'/ type: "T_JSBODY"
        - when: /`(?:[^`\\]|\\.)*`/ type: "T_JSBODY"
        - when: /\/(?:[^\/\\]|\\.)+\/[gmiyu]*/ type: "T_JSBODY"
        - when: /\/\/[\n]*/ type: "T_JSBODY"
        - when: /\/\*.*\*\// type: "T_JSBODY"
    string ->
        - when: /"(?:[^"\\]|\\.)*"/ type: "T_STRING"
    string2 ->
        - when: /'(?:[^'\\]|\\.)*'/ type: "T_STRING"
    string3 ->
        - when: /`(?:[^`\\]|\\.)*`/ type: "T_STRING"
    charclass ->
        - when: /\[(?:[^\]\\]|\\.)+\]/ type: "T_CHARCLASS"
    regex ->
        - when: /\/(?:[^\/\\]|\\.)+\/[gmiyu]*/ type: "T_REGEX"
    integer ->
        - when: /\d+/ type: "integer"
    word ->
        - when: /[a-zA-Z_][a-zA-Z_\d]*/ type: "T_WORD"
    ws ->
        - when: /\s+/ type: "T_WS"
    k_all ->
        - when: /all(?![a-zA-Z\d_])/ type: "K_ALL"
    k_tag ->
        - when: /tag(?![a-zA-Z\d_])/ type: "K_TAG"
    k_type ->
        - when: /type(?![a-zA-Z\d_])/ type: "K_TYPE"
    k_when ->
        - when: /when(?![a-zA-Z\d_])/ type: "K_WHEN"
    k_pop ->
        - when: /pop(?![a-zA-Z\d_])/ type: "K_POP"
    k_inset ->
        - when: /inset(?![a-zA-Z\d_])/ type: "K_INSET"
    k_set ->
        - when: /set(?![a-zA-Z\d_])/ type: "K_SET"
    k_goto ->
        - when: /goto(?![a-zA-Z\d_])/ type: "K_GOTO"
    k_config ->
        - when: /config(?![a-zA-Z\d_])/ type: "K_CONFIG"
    k_lexer ->
        - when: /lexer(?![a-zA-Z\d_])/ type: "K_LEXER"
    k_grammar ->
        - when: /grammar(?![a-zA-Z\d_])/ type: "K_GRAMMAR"
    k_import ->
        - when: /import(?![a-zA-Z\d_])/ type: "K_IMPORT"
    k_body ->
        - when: /body(?![a-zA-Z\d_])/ type: "K_BODY"
    k_head ->
        - when: /head(?![a-zA-Z\d_])/ type: "K_HEAD"
    l_colon ->
        - when: ":" type: "L_COLON"
    l_ebnf_0 ->
        - when: ":?" type: "L_EBNF_0"
    l_ebnf_1n ->
        - when: ":+" type: "L_EBNF_1N"
    l_ebnf_0n ->
        - when: ":*" type: "L_EBNF_0N"
    l_comma ->
        - when: "," type: "L_COMMA"
    l_pipe ->
        - when: "|" type: "L_PIPE"
    l_parenl ->
        - when: "(" type: "L_PARENL"
    l_parenr ->
        - when: ")" type: "L_PARENR"
    l_templatel ->
        - when: "{{" type: "L_TEMPLATEL"
    l_templater ->
        - when: "}}" type: "L_TEMPLATER"
    l_arrow ->
        - when: "->" type: "L_ARROW"
    l_dsign ->
        - when: "$" type: "L_DSIGN"
    l_dash ->
        - when: "-" type: "L_DASH"
    comment ->
        - when: /\/\/[\n]*/ type: "T_COMMENT"
    commentmulti ->
        - when: /\/\*.*\*\// type: "T_COMMENT"
}}

grammar{{
    main ->
        _ section_list _  ${ ({data}) => data[1] }

    section_list -> 
        section ${ ({data}) => [data[0]] }
        | section T_WS section_list  ${ ({data}) => [data[0]].concat(data[2]) }

    section ->   
        K_CONFIG _ L_TEMPLATEL _ kv_list _ L_TEMPLATER ${ ({data})=>({ config: Rollup(data[4]) }) }
        | K_LEXER _ L_TEMPLATEL _ lexer _ L_TEMPLATER ${ ({data})=>({ lexer: Rollup(data[4]) }) }
        | K_GRAMMAR _ L_TEMPLATEL _ grammar _ L_TEMPLATER ${ ({data})=>({ grammar: data[4] }) }
        | K_IMPORT _ T_WORD ${ ({data}) => { return { import: data[2] }} }
        | K_BODY _ T_JS ${ ({data}) => { return { body: data[2] }} }
        | K_HEAD _ T_JS ${ ({data}) => { return { head: data[2] }} }
        | K_IMPORT _ T_STRING ${ ({data}) => { return { import: data[2], path: true }} }
        | K_BODY _ T_STRING ${ ({data}) => { return { body: data[2], path: true }} }
        | K_HEAD _ T_STRING ${ ({data}) => { return { head: data[2], path: true }} }

    lexer -> 
        kv_list _ state_list ${ ({data}) => data[0].concat({ states: data[2] }) } 
        | state_list ${ ({data})=> [{ states: data[0] }] } 

    state_list -> 
        state ${ ({data}) => data }
        | state _ state_list  ${ ({data}) => [data[0]].concat(data[2]) } 

    state -> 
        state_declare _ state_definition ${ ({data}) => Rollup([{ name: data[0] }].concat(data[2])) }
    state_declare -> 
        T_WORD _ L_ARROW ${ ({data}) => data[0] }
    state_definition -> 
        kv_list _ token_list ${ ({data})=> Rollup(data[0].concat([{rules: data[2]}])) } 
        | token_list ${ ({data})=> ({ rules: data[0] }) } 

    word_list -> 
        T_WORD ${ ({data}) => [data[0]] }
        | T_WORD _ L_COMMA _ word_list  ${ ({data}) => [data[0]].concat(data[4]) }

    token_list -> 
        token ${ ({data}) => data }
        | token _ token_list  ${ ({data}) => [data[0]].concat(data[2]) }

    token -> 
        L_DASH _ K_IMPORT _ L_COLON _ word_list ${({data})=>({ import: data[6] })}
        | L_DASH _ token_definition_list ${ ({data}) => Rollup(data[2]) }

    token_definition_list -> 
        token_definition ${ ({data}) => data }
        | token_definition _ token_definition_list  ${ ({data}) => [data[0]].concat(data[2]) }

    token_definition -> 
        tag ${ ({data})=> data[0] }
        | when ${ ({data})=> data[0] }
        | pop ${ ({data})=> data[0] }
        | inset ${ ({data})=> data[0] }
        | set ${ ({data})=> data[0] }
        | goto ${ ({data})=> data[0] }
        | type ${ ({data})=> data[0] }

        
    tag -> 
        K_TAG _ L_COLON _ string_list ${({data})=>({ tag: data[4] })}

    when -> 
        K_WHEN _ L_COLON _ T_STRING ${({data})=>({ when: data[4] })}
        | K_WHEN _ L_COLON _ T_REGEX ${({data})=>({ when: data[4] })}

    type -> K_TYPE _ L_COLON _ T_STRING ${({data})=>({ type: data[4] })}

    pop ->
        K_POP ${ ({data})=> ({ pop: 1 }) } 
        | K_POP _ L_COLON _ T_NUMBER ${ ({data})=> ({ pop: parseInt(data[4]) }) } 
        | K_POP _ L_COLON _ K_ALL ${ ({data})=> ({ pop: "all" }) } 
        
    inset -> 
        K_INSET  ${ ({data})=> ({ inset: 1 }) } 
        | K_INSET _ L_COLON _ T_NUMBER ${ ({data})=> ({ inset: parseInt(data[4]) }) } 

    set -> 
        K_SET _ L_COLON _ T_WORD ${ ({data})=> ({ set: data[4] }) } 
    goto -> 
        K_GOTO _ L_COLON _ T_WORD ${ ({data})=> ({ goto: data[4] }) } 


    grammar -> 
        kv_list _ rule_list ${ ({data})=> ({ config: Rollup(data[0]), rules: data[2] }) } 
        | rule_list ${ ({data})=> ({ rules: data[0] }) } 

    rule_list -> 
        rule ${ ({data}) => [data[0]] }
        | rule _ rule_list  ${ ({data}) => [data[0]].concat(data[2]) }

    rule ->
        T_WORD _ L_ARROW _ expression_ext ${ ({data}) => { return { name: data[0], rules: data[4] }} }

    expression_ext -> 
        completeexpression
        | expression_ext _ L_PIPE _ completeexpression ${ ({data}) => data[0].concat([data[4]]) }

    completeexpression -> 
        expr ${ ({data}) => { return { tokens: data[0] }} }
        | expr _ T_JS ${ ({data}) => { return { tokens: data[0], postprocess: data[2] }} }
        | expr _ T_GRAMMAR_TEMPLATE ${ ({data}) => { return { tokens: data[0], postprocess: TemplatePostProcess(data[2]) }} }


    expr_member ->
        T_WORD ${ ({data}) => data[0] }
        | T_STRING "i":? ${ ({data}) => { return data[1] ? Insensitive(data[0]) : data[0] } }
        | L_DSIGN T_WORD ${ ({data}) => { return { token: data[1]}} }
        | T_CHARCLASS ${ ({data}) => data[0] }
        | L_PARENL _ expression_ext _ L_PARENR ${ ({data}) => { return { 'subexpression': data[2] }} }
        | expr_member _ ebnf_modifier ${ ({data}) => { return { 'ebnf': data[0], 'modifier': data[2] }} }

    ebnf_modifier -> 
        (L_EBNF_0 | L_EBNF_1N | L_EBNF_0N) ${ ({ data }) => data[0] }

    expr ->
        expr_member
        | expr T_WS expr_member  ${ ({data}) => data[0].concat([data[2]]) }

    kv_list -> 
        kv ${ ({data}) => data }
        | kv _ kv_list  ${ ({data}) => [data[0]].concat(data[2]) }

    kv ->
        T_WORD _ L_COLON _ (T_WORD|T_STRING|T_NUMBER) ${({data})=>({ [data[0]]: data[4][0] })}

    string_list -> 
        T_STRING ${ ({data}) => [data[0]] }
        | T_STRING _ L_COMMA _ string_list  ${ ({data}) => [data[0]].concat(data[4]) }

    _ -> 
        T_WS:? ${ ()=> null }

    L_COLON -> ":"
    L_EBNF_0 -> ":?"
    L_EBNF_1N -> ":+"
    L_EBNF_0N -> ":*"
    L_COMMA -> ","
    L_PIPE -> "|"
    L_PARENL -> "("
    L_PARENR -> ")"
    L_TEMPLATEL -> "{{"
    L_TEMPLATER -> "}}"
    L_ARROW -> "->"
    L_DSIGN -> "$"
    L_DASH -> "-"


    K_ALL -> "all"
    K_TAG -> "tag"
    K_TYPE -> "type"
    K_WHEN -> "when"
    K_POP -> "pop"
    K_INSET -> "inset"
    K_SET -> "set"
    K_GOTO -> "goto"
    K_CONFIG -> "config" 
    K_LEXER -> "lexer"
    K_GRAMMAR -> "grammar"
    K_IMPORT -> "import"
    K_BODY -> "body"
    K_HEAD -> "head"
    
    T_JS -> "${" [^}]:+ "}" ${ ({data}) => data[1].join('') }
    T_GRAMMAR_TEMPLATE -> "{{" [^}]:+ "}}" ${ ({data}) => data[1].join('') }
    T_STRING -> "\"" [^"]:+ "\"" ${ ({data}) => data[1].join('') }
    T_WORD -> [a-z] [a-zA-Z_\d]:* ${ ({data}) => data.flat().join('') }
    T_REGEX -> "/" [^/]:+ "/" ${ ({data}) => data.flat().join('') }
    T_COMMENT -> "//" [^\n]:+ 
    T_CHARCLASS -> "[" [^\]]:+ "]"  ${ ({ data }) => data[0] }
    T_NUMBER -> [\d]:+ ${ ({data}) => data.flat().join('') }
    T_WS -> [\s]:+ ${()=>null}

}}